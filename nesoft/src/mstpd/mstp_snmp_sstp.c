/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.pacos.conf $
 */
#include "pal.h"
#include "lib.h"

#ifdef HAVE_SNMP

#include "asn1.h"
#include "if.h"
#include "log.h"
#include "prefix.h"
#include "table.h"
#include "snmp.h"
#include "l2lib.h"
#include "pal_math.h"
#include "l2_snmp.h"
#include "l2_timer.h"
#include "bitmap.h"

#include "mstp_config.h"
#include "mstpd.h"
#include "mstp_types.h"
#include "mstp_bridge.h"
#include "mstp_api.h"
#include "mstp_port.h"
#include "mstp_snmp.h"
#include "mstp_transmit.h"
#include "mstp_snmp_sstp.h"


u_int8_t *mstp_string_val;
static int mstp_int_val;
static u_long mstp_ulong_val;
static struct bridge_id mstp_snmp_bridge_id;

int mstp_snmp_dot1sStpProtocolSpecification = 5; /* ieee8021s(5) */
/*
 * dot1sStp_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
/* As per malhotra-mstpmib-01 the OID should be { dot1dBridge 7 } 
 * but in the current standards { dot1dBridge 7 } has been assigned for 
 * Q-BRIDGE MIB */
#ifdef HAVE_STD_MALHOTRA_MIB
oid             dot1sStp_variables_oid[] = { 1, 3, 6, 1, 2, 1, 17, 7};
#else
oid             dot1sStp_variables_oid[] = { 1, 3, 6, 1, 2, 1, 17, 99 };
#endif /* HAVE_STD_MALHOTRA_MIB */

/*
 * variable dot1sStp_variables:
 *   this variable defines function callbacks and type return information 
 *   for the dot1sStp mib section 
 */

struct variable dot1sStp_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define DOT1SSTPNAME		1
    {DOT1SSTPNAME, ASN_OCTET_STR, RWRITE, var_dot1sStp, 1, {1}},
#define DOT1SSTPREVISION		2
    {DOT1SSTPREVISION, ASN_INTEGER, RWRITE, var_dot1sStp, 1, {2}},
#define DOT1SSTPENABLE		3
    {DOT1SSTPENABLE, ASN_INTEGER, RWRITE, var_dot1sStp, 1, {3}},
#define DOT1SSTPBRIDGEMAXAGE		4
    {DOT1SSTPBRIDGEMAXAGE, ASN_INTEGER, RWRITE, var_dot1sStp, 1, {4}},
#define DOT1SSTPBRIDGEHELLOTIME		5
    {DOT1SSTPBRIDGEHELLOTIME, ASN_INTEGER, RWRITE, var_dot1sStp, 1, {5}},
#define DOT1SSTPBRIDGEFORWARDDELAY		6
    {DOT1SSTPBRIDGEFORWARDDELAY, ASN_INTEGER, RWRITE, var_dot1sStp, 1,
     {6}},
#define DOT1SSTPTXHOLDCOUNT		7
    {DOT1SSTPTXHOLDCOUNT, ASN_INTEGER, RONLY, var_dot1sStp, 1, {7}},
#define DOT1SSTPPROTOCOLSPECIFICATION		8
    {DOT1SSTPPROTOCOLSPECIFICATION, ASN_INTEGER, RONLY, var_dot1sStp, 1,
     {8}},

#define DOT1SSTPINSTID		9
    {DOT1SSTPINSTID, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 1}},
#define DOT1SSTPPRIORITY		10
    {DOT1SSTPPRIORITY, ASN_INTEGER, RWRITE, var_dot1sStpInstTable, 3,
     {9, 1, 2}},
#define DOT1SSTPINSTTIMESINCETOPOLOGYCHANGE		11
    {DOT1SSTPINSTTIMESINCETOPOLOGYCHANGE, ASN_TIMETICKS, RONLY,
     var_dot1sStpInstTable, 3, {9, 1, 3}},
#define DOT1SSTPINSTTOPCHANGES		12
    {DOT1SSTPINSTTOPCHANGES, ASN_COUNTER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 4}},
#define DOT1SSTPINSTDESIGNATEDROOT		13
    {DOT1SSTPINSTDESIGNATEDROOT, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 5}},
#define DOT1SSTPINSTROOTCOST		14
    {DOT1SSTPINSTROOTCOST, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 6}},
#define DOT1SSTPINSTROOTPORT		15
    {DOT1SSTPINSTROOTPORT, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 7}},
#define DOT1SSTPINSTMAXAGE		16
    {DOT1SSTPINSTMAXAGE, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 8}},
#define DOT1SSTPINSTHELLOTIME		17
    {DOT1SSTPINSTHELLOTIME, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 9}},
#define DOT1SSTPINSTFORWARDDELAY		18
    {DOT1SSTPINSTFORWARDDELAY, ASN_INTEGER, RONLY, var_dot1sStpInstTable,
     3, {9, 1, 10}},
#define DOT1SSTPINSTADMINENABLE		19
    {DOT1SSTPINSTADMINENABLE, ASN_INTEGER, RWRITE, var_dot1sStpInstTable,
     3, {9, 1, 11}},
#define DOT1SSTPINSTOPERENABLE		20
    {DOT1SSTPINSTOPERENABLE, ASN_INTEGER, RONLY, var_dot1sStpInstTable, 3,
     {9, 1, 12}},
#define DOT1SSTPPORT		21
    {DOT1SSTPPORT, ASN_INTEGER, RONLY, var_dot1sStpPortTable, 3,
     {10, 1, 1}},
#define DOT1SSTPPORTADMINEDGEPORT		22
    {DOT1SSTPPORTADMINEDGEPORT, ASN_INTEGER, RWRITE, var_dot1sStpPortTable,
     3, {10, 1, 2}},
#define DOT1SSTPPORTADMINPOINTTOPOINT		23
    {DOT1SSTPPORTADMINPOINTTOPOINT, ASN_INTEGER, RWRITE,
     var_dot1sStpPortTable, 3, {10, 1, 3}},
#define DOT1SSTPPORTOPEREDGEPORT		24
    {DOT1SSTPPORTOPEREDGEPORT, ASN_INTEGER, RONLY, var_dot1sStpPortTable,
     3, {10, 1, 4}},
#define DOT1SSTPPORTOPERPOINTTOPOINT		25
    {DOT1SSTPPORTOPERPOINTTOPOINT, ASN_INTEGER, RONLY,
     var_dot1sStpPortTable, 3, {10, 1, 5}},
#define DOT1SSTPVERSION		26
    {DOT1SSTPVERSION, ASN_INTEGER, RONLY, var_dot1sStpPortTable, 3,
     {10, 1, 6}},
#define DOT1SSTPINSTPORTPRIORITY		27
    {DOT1SSTPINSTPORTPRIORITY, ASN_INTEGER, RWRITE,
     var_dot1sStpInstPortTable, 3, {11, 1, 1}},
#define DOT1SSTPINSTPORTSTATE		28
    {DOT1SSTPINSTPORTSTATE, ASN_INTEGER, RONLY, var_dot1sStpInstPortTable,
     3, {11, 1, 2}},
#define DOT1SSTPINSTPORTPATHCOST		29
    {DOT1SSTPINSTPORTPATHCOST, ASN_INTEGER, RWRITE,
     var_dot1sStpInstPortTable, 3, {11, 1, 3}},
#define DOT1SSTPINSTPORTDESIGNATEDROOT		30
    {DOT1SSTPINSTPORTDESIGNATEDROOT, ASN_INTEGER, RONLY, var_dot1sStpInstPortTable, 3,
     {11, 1, 4}},
#define DOT1SSTPINSTPORTDESIGNATEDCOST		31
    {DOT1SSTPINSTPORTDESIGNATEDCOST, ASN_INTEGER, RONLY,
     var_dot1sStpInstPortTable, 3, {11, 1, 5}},
#define DOT1SSTPINSTPORTDESIGNATEDBRIDGE		32
    {DOT1SSTPINSTPORTDESIGNATEDBRIDGE,ASN_INTEGER, RONLY, var_dot1sStpInstPortTable,
     3, {11, 1, 6}},
#define DOT1SSTPINSTPORTDESIGNATEDPORT		33
    {DOT1SSTPINSTPORTDESIGNATEDPORT, ASN_OCTET_STR, RONLY,
     var_dot1sStpInstPortTable, 3, {11, 1, 7}},
#define DOT1SSTPINSTPORTFORWARDTRANSITIONS		34
    {DOT1SSTPINSTPORTFORWARDTRANSITIONS, ASN_COUNTER, RONLY,
     var_dot1sStpInstPortTable, 3, {11, 1, 8}},
#define DOT1SSTPINSTPORTROLE		35
    {DOT1SSTPINSTPORTROLE, ASN_INTEGER, RONLY, var_dot1sStpInstPortTable,
     3, {11, 1, 9}},
#define DOT1SSTPVLANMSTINDEX		36
    {DOT1SSTPVLANMSTINDEX, ASN_INTEGER, RONLY, var_dot1sStpVlanTable, 3,
     {12, 1, 1}},
#define DOT1SSTPVLANRANGEINDEX		37
    {DOT1SSTPVLANRANGEINDEX, ASN_INTEGER, RONLY, var_dot1sStpVlanTable, 3,
     {12, 1, 2}},
#define DOT1SSTPVLANMIN		38
    {DOT1SSTPVLANMIN, ASN_INTEGER, RWRITE, var_dot1sStpVlanTable, 3,
     {12, 1, 3}},
#define DOT1SSTPVLANMAX		39
    {DOT1SSTPVLANMAX, ASN_INTEGER, RWRITE, var_dot1sStpVlanTable, 3,
     {12, 1, 4}},
#define DOT1SSTPVLANROWSTATUS		40
    {DOT1SSTPVLANROWSTATUS, ASN_INTEGER, RWRITE, var_dot1sStpVlanTable, 3,
     {12, 1, 5}},
};

/*
 * (L = length of the oidsuffix) 
 */

    /*
     * variables we may use later 
     */
/*static int32_t  int_ret;
static u_int32_t uint_ret;
static unsigned char str[SPRINT_MAX_LEN];*/


/** Initializes the dot1sStp module */
void
init_dot1sStp(struct lib_globals *zg)
{
  /*
   * register ourselves with the agent to handle our mib tree 
   */
  REGISTER_MIB(zg, "dot1sStp", dot1sStp_variables, variable,
               dot1sStp_variables_oid);

  /*
   * place any other initialization junk you need here 
   */
  pal_mem_set (&tmp_rlist_info, 0, sizeof (struct tmp_rlist_data));
}

/*
 * given a bridge, instance and exact/inexact request, returns a pointer to
 * an stp_port structure or NULL if none found.
 */
struct mstp_bridge_instance *
mstp_snmp_bridge_instance_lookup (struct mstp_bridge *br, u_int32_t instance_id,
                                  int exact)
{
  struct mstp_bridge_instance *curr = NULL;
  struct mstp_bridge_instance *best = NULL; /* assume none found */
  u_int16_t indx;

  if (br == NULL)
    return NULL;
  
  if (exact)
    {
      return br->instance_list[instance_id]; 
    }
  else
    {
      /* Get next */
      for (indx = 1; indx < MST_MAX_INSTANCES; indx = indx+1)
        {
          curr = NULL;
          
          curr = br->instance_list[indx];

          if (curr == NULL)
            continue;

          if (instance_id < curr->instance_id)
            {
              /* save if this is a better candidate and
               *   continue search
               */
              if (best == NULL)
                best = curr;
              else if (curr->instance_id < best->instance_id)
                best = curr;
            }
        }
      return best;
    } /* Get next */
  return NULL;
}

struct mstp_instance_port *
mstp_snmp_instance_port_lookup (struct mstp_bridge *br, u_int32_t instIndx,
                                u_int32_t portIndx, int exact)
{
  struct mstp_bridge_instance *br_inst = NULL;
  struct mstp_instance_port *inst_port = NULL;
  struct mstp_instance_port *curr = NULL;
  struct mstp_instance_port *best = NULL; /* assume none found */
  u_int16_t j = 0;

  if (br == NULL)
    return NULL;

  if (exact)
    {
      br_inst = br->instance_list[instIndx];

      if (br_inst == NULL)
        return NULL;
    
      inst_port = mstp_find_msti_port (br_inst, portIndx);
      
      if (inst_port == NULL)
        return NULL;
      else
        return inst_port;
    }
  else
    {
      /* Get next */
      for (j = 1; j < MST_MAX_INSTANCES; j++)
        {
          if (br->instance_list[instIndx])
            br_inst =  br->instance_list[instIndx];
          else
            br_inst = mstp_snmp_bridge_instance_lookup (br, instIndx, exact);

          if (br_inst == NULL)
            return NULL;

          for (curr = br_inst->port_list; curr; curr = curr->next)
            {
              if (portIndx < curr->ifindex)
                {
                  /* save if this is a better candidate and
                   *   continue search
                   */
                  if (best == NULL)
                    best = curr;
                  else if (curr->ifindex < best->ifindex)
                    best = curr;
                }/* if (portIndx < curr->ifindex) */
            }/* for (curr = br_inst->port_list; curr; curr = curr->next) */

          if (best == NULL)
            {
              instIndx++;
              portIndx = 0;
            }
          else
            break;
        }/* for (j = 1; j < MST_MAX_INSTANCES; j++) */
      return best;
    } /* Get next */

  return NULL;
}

struct rlist_info *
mstp_instance_entry_get_by_index (struct mstp_bridge *bridge,
                                  u_int32_t *br_instance_val,
                                  u_int32_t instance_id, 
                                  u_int32_t vlan_range_index, int exact)

{
  struct mstp_bridge_instance *br_inst = NULL; 
  struct rlist_info *vlan_list = NULL;
  struct rlist_info *best_vlan_node = NULL;
  struct bitmap *bitmap = NULL;
  struct bitmap_block *block = NULL;
  int i = 0 ;
  int j = 0 ;
  int bits;
  int offset;

  if (exact)
    {
      if ((instance_id <= MST_MAX_INSTANCES))
        {

          /* Check for the instance in the bridge. */
          br_inst = bridge->instance_list[instance_id];
          if (br_inst == NULL)  
            return NULL;

          *br_instance_val = br_inst->instance_id;

          /* Check for the Vlan Range Index. */ 
          vlan_list = br_inst->vlan_list;

          while (vlan_list)
            {
              if (vlan_list->vlan_range_indx == vlan_range_index)
                return vlan_list;

              vlan_list = vlan_list->next;
            }
        }

      return NULL;
    }   

  else
    {
      for (j = 1; j < MST_MAX_INSTANCES; j++)
        { 
          /* First check the given instance. If not found then
           * go for the best match.
           */
          if (bridge->instance_list[instance_id])
            br_inst =  bridge->instance_list[instance_id];
          else
            { 
              br_inst = mstp_snmp_bridge_instance_lookup (bridge, instance_id, exact);
            }  

          if (br_inst == NULL)
            {
              return NULL;
            }

          *br_instance_val = br_inst->instance_id;

          bitmap = br_inst->vlan_range_index_bmp;

          for (i = 0; i <= 4094; i++)
            {
              block = bitmap_block_get (bitmap, i);
              if (! block)
                {
                  continue;
                }  

              bits = i % INDEX_VALUE_MAX;
              offset = (i % bitmap->block_size) / INTEGER_BITS;

              if (!CHECK_FLAG (block->map[offset], 1 << bits))
                { 
                  if (vlan_range_index < i) 
                    { 
                      vlan_list = br_inst->vlan_list;

                      while (vlan_list)
                        {
                          if (vlan_list->vlan_range_indx == i)
                            {
                              break;
                            }

                          vlan_list = vlan_list->next;
                        }

                      if (vlan_list == NULL)
                        continue;                  

                      if (best_vlan_node == NULL)
                        best_vlan_node  = vlan_list;
                      else if (vlan_list->vlan_range_indx < 
                          best_vlan_node->vlan_range_indx)
                        best_vlan_node = vlan_list;

                    }/* if (vlan_range_index < i) */
                }/* if (!CHECK_FLAG (block->map[offset], 1 << bits)) */
            }/* for (i = 0; i <= 4094; i++) */

          if (best_vlan_node == NULL)
            {
              instance_id++;
              vlan_range_index = 0;
            }
          else
            break;       
        } /* Instance Loop. */
      return best_vlan_node;
    } /* get next */

  return NULL;
}


/*
 * var_dot1sStp():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_dot1sStp(struct variable *vp, oid * name,
             size_t *length, int exact,
             size_t *var_len, WriteMethod ** write_method, u_int32_t vr_id)
{
  struct mstp_bridge *br = NULL;
  
  if (snmp_header_generic(vp, name, length, exact, var_len, write_method)
      == MATCH_FAILED)
      return NULL;

  switch (vp->magic) {
  case DOT1SSTPNAME:
      *write_method = write_dot1sStp_scalars;
      break;
  case DOT1SSTPREVISION:
      *write_method = write_dot1sStp_scalars;
      break;
  case DOT1SSTPENABLE:
      *write_method = write_dot1sStp_scalars;
      break;
  case DOT1SSTPBRIDGEMAXAGE:
      *write_method = write_dot1sStp_scalars;
      break;
  case DOT1SSTPBRIDGEHELLOTIME:
      *write_method = write_dot1sStp_scalars;
      break;
  case DOT1SSTPBRIDGEFORWARDDELAY:
      *write_method = write_dot1sStp_scalars;
      break;
  default:
      break;
  }

  br = mstp_get_first_bridge();

  if (br == NULL)
    return NULL;

  /*
   * this is where we do the value assignments for the mib results.
   */
  switch (vp->magic) {
  case DOT1SSTPNAME:
      {
        *write_method = write_dot1sStp_scalars;
        MSTP_SNMP_RETURN_STRING (br->config.cfg_name, sizeof (br->config.cfg_name));
      }
      break;
  case DOT1SSTPREVISION:
      {
        *write_method = write_dot1sStp_scalars;
        MSTP_SNMP_RETURN_INTEGER (br->config.cfg_revision_lvl);
      }
      break;
  case DOT1SSTPENABLE:
        {
          *write_method = write_dot1sStp_scalars;
          MSTP_SNMP_RETURN_INTEGER (br->mstp_enabled);
        }
      break;
  case DOT1SSTPBRIDGEMAXAGE:
        {
          *write_method = write_dot1sStp_scalars;
          MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT
              (br->bridge_max_age));
        }
      break;

  case DOT1SSTPBRIDGEHELLOTIME:
        {
          *write_method = write_dot1sStp_scalars;
          MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT
              (br->bridge_hello_time));
        }
      break;

  case DOT1SSTPBRIDGEFORWARDDELAY:
        {
          *write_method = write_dot1sStp_scalars;
          MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT (
                                    br->bridge_forward_delay));
        }
      break;

  case DOT1SSTPTXHOLDCOUNT:
      MSTP_SNMP_RETURN_INTEGER (br->transmit_hold_count);
      break;

  case DOT1SSTPPROTOCOLSPECIFICATION:
      MSTP_SNMP_RETURN_INTEGER (mstp_snmp_dot1sStpProtocolSpecification);
      break;

  default:
      return NULL;
  }
  return NULL;
}


/*
 * var_dot1sStpInstTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1sStp above.
 */
unsigned char  *
var_dot1sStpInstTable(struct variable *vp, oid * name,
                      size_t *length, int exact,
                      size_t *var_len, WriteMethod ** write_method,
                      u_int32_t vr_id)
{
  /*
   * this is where we do the value assignments for the mib results.
   */
  int ret;
  static u_int32_t instance_index = 0;
  struct mstp_bridge *br = NULL;
  struct mstp_bridge_instance *br_inst = NULL;

  /* Write methods */
  switch (vp->magic) {
    case DOT1SSTPPRIORITY:
      *write_method = write_dot1sStpInstTable;
      break;

    case DOT1SSTPINSTADMINENABLE:
      *write_method = write_dot1sStpInstTable;
      break;

    default:
      break;
  }

  ret = l2_snmp_index_get (vp, name, length, &instance_index, exact);

  if (ret < 0)
    return NULL;

  br = mstp_get_first_bridge ();
  if (br == NULL)
    {
      return NULL;
    }

  br_inst = mstp_snmp_bridge_instance_lookup (br,instance_index, exact);

  if (br_inst == NULL)
    return NULL;

  if (!exact)
    {
      l2_snmp_index_set (vp, name, length, br_inst->instance_id);
    }

  switch (vp->magic) {
  case DOT1SSTPINSTID:
      MSTP_SNMP_RETURN_INTEGER (br_inst->instance_id);
      break;
  case DOT1SSTPPRIORITY:
      *write_method = write_dot1sStpInstTable;
      MSTP_SNMP_RETURN_INTEGER (br_inst->msti_bridge_priority);
      break;
  case DOT1SSTPINSTTIMESINCETOPOLOGYCHANGE:
      /* This is not maintained per instance but is maintained for the bridge */
      MSTP_SNMP_RETURN_TIMETICKS (time_ticks(pal_time_current(NULL),
                                             br->time_last_topo_change));
      break;
  case DOT1SSTPINSTTOPCHANGES:
      /* This is not maintained per instance but is maintained for the bridge */
      MSTP_SNMP_RETURN_INTEGER (br->num_topo_changes);
      break;
  case DOT1SSTPINSTDESIGNATEDROOT:
      MSTP_SNMP_RETURN_BRIDGEID (br_inst->msti_designated_root);
      break;
  case DOT1SSTPINSTROOTCOST:
      MSTP_SNMP_RETURN_INTEGER (br_inst->internal_root_path_cost);
      break;
  case DOT1SSTPINSTROOTPORT:
      MSTP_SNMP_RETURN_INTEGER (br_inst->msti_root_port_id & 0xfff);
      break;
  case DOT1SSTPINSTMAXAGE:
      /* max_age, hello_time and forward_delay are not supported on a per 
       * instance basis presently. Returning the values at the bridge */
      MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT
                                (br->bridge_max_age));
      break;
  case DOT1SSTPINSTHELLOTIME:
      /* max_age, hello_time and forward_delay are not supported on a per 
       * instance basis presently. Returning the values at the bridge */
      MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT
                                (br->bridge_hello_time));
      break;
  case DOT1SSTPINSTFORWARDDELAY:
      /* max_age, hello_time and forward_delay are not supported on a per 
       * instance basis presently. Returning the values at the bridge */
      MSTP_SNMP_RETURN_INTEGER (MSTP_SNMP_TIMER_TO_TIMEOUT (br->bridge_forward_delay));
      break;
  case DOT1SSTPINSTADMINENABLE:
      *write_method = write_dot1sStpInstTable;
#if defined (HAVE_PROVIDER_BRIDGE) || defined (HAVE_B_BEB)
      MSTP_SNMP_RETURN_INTEGER (br_inst->mstp_enabled);
#else
      /* Not supported on a per instance basis */
      MSTP_SNMP_RETURN_INTEGER (br->mstp_enabled);
#endif /*(HAVE_PROVIDER_BRIDGE) ||(HAVE_B_BEB)*/
      break;
  case DOT1SSTPINSTOPERENABLE:
      /* This is presently not supported in the implementation */
      MSTP_SNMP_RETURN_INTEGER (DOT1SSTPINSTOPERENABLE_TRUE);
      break;
  default:
      return NULL;
  }
  return NULL;
}

/*
 * var_dot1sStpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1sStp above.
 */
unsigned char  *
var_dot1sStpPortTable(struct variable *vp, oid * name,
                      size_t *length, int exact,
                      size_t *var_len, WriteMethod ** write_method,
                      u_int32_t vr_id)
{
  /*
   * this is where we do the value assignments for the mib results.
   */
  int ret;
  static u_int32_t index = 0;
  struct mstp_bridge *br = NULL;
  struct mstp_port *br_port = NULL;

  switch (vp->magic) {
    case DOT1SSTPPORTADMINEDGEPORT:
      *write_method = write_dot1sStpPortTable;
      break;
  case DOT1SSTPPORTADMINPOINTTOPOINT:
      *write_method = write_dot1sStpPortTable;
      break;
  default:
      break;
  }

  /* validate the index */
  ret = l2_snmp_index_get (vp, name, length, &index, exact);
  if (ret < 0)
    return NULL;

  br = mstp_get_first_bridge();
  if (br == NULL)
    return NULL;

  br_port = mstp_snmp_bridge_port_lookup (br, index, exact);
  if (br_port == NULL)
    return NULL;

  if (!exact)
    {
      l2_snmp_index_set (vp, name, length, br_port->ifindex);
    }

  switch (vp->magic) {
  case DOT1SSTPPORT:
      MSTP_SNMP_RETURN_INTEGER (br_port->ifindex);
      break;

  case DOT1SSTPPORTADMINEDGEPORT:
        {
          *write_method = write_dot1sStpPortTable;
          if (br_port->admin_edge) 
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTADMINEDGEPORT_TRUE);
          else
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTADMINEDGEPORT_FALSE);
        }
      break;
  
  case DOT1SSTPPORTADMINPOINTTOPOINT:
        {  
          *write_method = write_dot1sStpPortTable;
          if (br_port->admin_p2p_mac)
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTADMINPOINT2POINT_TRUE);
          else
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTADMINPOINT2POINT_FALSE);
        }
      break;
  case DOT1SSTPPORTOPEREDGEPORT:
        {
          if (br_port->oper_edge)
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTOPEREDGEPORT_TRUE);
          else 
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTOPEREDGEPORT_FALSE);
        }
      break;

  case DOT1SSTPPORTOPERPOINTTOPOINT:
        {
          if (br_port->oper_p2p_mac)
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTOPERPOINT2POINT_TRUE);
          else 
            MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTOPERPOINT2POINT_FALSE);
        }

      break;
  case DOT1SSTPVERSION:
          MSTP_SNMP_RETURN_INTEGER (br_port->force_version);
      break;
  default:
      return NULL;
  }
  return NULL;
}

/*
 * var_dot1sStpInstPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1sStp above.
 */
unsigned char  *
var_dot1sStpInstPortTable(struct variable *vp, oid * name,
                          size_t *length, int exact,
                          size_t *var_len, WriteMethod ** write_method,
                          u_int32_t vr_id)
{
  /*
   * this is where we do the value assignments for the mib results.
   */
  struct mstp_bridge *br = NULL;
  struct mstp_instance_port *inst_port = NULL;
  s_int32_t ret;
  u_int32_t instIndx;
  u_int32_t portIndx;

  switch (vp->magic) {
  case DOT1SSTPINSTPORTPRIORITY:
      *write_method = write_dot1sStpInstPortTable;
      break;
  case DOT1SSTPINSTPORTPATHCOST:
      *write_method = write_dot1sStpInstPortTable;
      break;
  default:
      break;
    }

  ret = l2_snmp_integer_index_get (vp, name, length,
      &instIndx, &portIndx, exact);

  if (ret < 0 )
    return NULL;
      
  br = mstp_get_first_bridge();
  if (br == NULL)
    return NULL;

  inst_port = mstp_snmp_instance_port_lookup (br, instIndx, portIndx, exact);

  if (inst_port == NULL)
    return NULL;
  
  if (!exact)
    {
      l2_snmp_integer_index_set (vp, name, length, inst_port->br->instance_id,
                                 inst_port->ifindex);
    }

  switch (vp->magic) {
  case DOT1SSTPINSTPORTPRIORITY:
      {
        *write_method = write_dot1sStpInstPortTable;

        MSTP_SNMP_RETURN_INTEGER (inst_port->msti_priority);
      }
      break;
  case DOT1SSTPINSTPORTSTATE:
      {
        if (inst_port->state == STATE_DISCARDING)
          MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTSTATE_DISCARDING); 
        else if (inst_port->state == STATE_LISTENING)
          MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTSTATE_LISTENING);
        else if (inst_port->state == STATE_LEARNING)
          MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTSTATE_LISTENING);
        else if (inst_port->state == STATE_FORWARDING)
          MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTSTATE_FORWARDING);
        else if (inst_port->state == STATE_BLOCKING)
          MSTP_SNMP_RETURN_INTEGER (DOT1SSTPPORTSTATE_DISABLED);
        else
          return NULL;
      }
      break;
      
  case DOT1SSTPINSTPORTPATHCOST:
      {
        *write_method = write_dot1sStpInstPortTable;
        MSTP_SNMP_RETURN_INTEGER (inst_port->msti_path_cost);
      }
      break;
      
  case DOT1SSTPINSTPORTDESIGNATEDROOT:
      /* Assumption here is that designated root is same as root */
      MSTP_SNMP_RETURN_BRIDGEID (inst_port->msti_root);
      break;
      
  case DOT1SSTPINSTPORTDESIGNATEDCOST:
      MSTP_SNMP_RETURN_INTEGER (inst_port->internal_root_path_cost);
      break;
      
  case DOT1SSTPINSTPORTDESIGNATEDBRIDGE:
      MSTP_SNMP_RETURN_BRIDGEID (inst_port->designated_bridge);
      break;
      
  case DOT1SSTPINSTPORTDESIGNATEDPORT:
      MSTP_SNMP_RETURN_INTEGER (pal_hton16(inst_port->designated_port_id));
      break;
      
  case DOT1SSTPINSTPORTFORWARDTRANSITIONS:
      /* This is presently not supported */
      break;

  case DOT1SSTPINSTPORTROLE:
      MSTP_SNMP_RETURN_INTEGER (inst_port->role);
      break;

  default:
      return NULL;
  }
  return NULL;
}

int
write_dot1sStpVlanTableRowStatus (int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP, oid * name,
                                  size_t name_len,
                                  struct variable *v,
                                  u_int32_t vr_id)
{
  int ret = 0;
  int instance_index;
  int vlan_range_index;
  struct mstp_bridge *br = NULL;
  struct mstp_bridge_instance *br_inst = NULL;
  struct rlist_info *vlan_list = NULL;
  s_int32_t intval;
  u_int32_t loop_vlan;

  if (var_val_type != ASN_INTEGER)
    return SNMP_ERR_WRONGTYPE;

  ret = l2_snmp_integer_index_get (v, name, &name_len,
                                   &instance_index ,&vlan_range_index,1);
  if (ret < 0)
    return SNMP_ERR_GENERR;
    
  br = mstp_get_first_bridge ();
  if (br == NULL)
    return SNMP_ERR_GENERR;
    
  pal_mem_cpy(&intval,var_val,4);

  if ((intval < ROW_STATUS_MIN) ||
      (intval > ROW_STATUS_MAX))
     return SNMP_ERR_BADVALUE;
 
  /* Check for the instance in the bridge. */
  br_inst = br->instance_list[instance_index];
 
  if (br_inst == NULL) 
    return SNMP_ERR_BADVALUE;

  /* Check for the Vlan Range Index. */ 
  vlan_list = br_inst->vlan_list;

  while (vlan_list)
    {

      /* Check if the Instance and Range Exists. */
      if (vlan_list->vlan_range_indx == vlan_range_index)
        {
          /* If it exists and the row status is not destroy return 
           * Error.
           */
          if (intval != ROW_STATUS_DESTROY)
            return SNMP_ERR_GENERR;
          else
            break;
        }
      if ((vlan_list->lo < tmp_rlist_info.lo) && 
          (vlan_list->hi > tmp_rlist_info.lo))
        {
          /* A lo value is given which is for a range which is already
           *  configured. */
          pal_mem_set (&tmp_rlist_info, 0, sizeof (struct tmp_rlist_data));
          return SNMP_ERR_BADVALUE;
        }

      if ((vlan_list->hi > tmp_rlist_info.hi) && 
          (vlan_list->lo < tmp_rlist_info.hi))
        {
          /* A hi value is given which is for a range which is already 
           * configured. */
          pal_mem_set (&tmp_rlist_info, 0, sizeof (struct tmp_rlist_data));
          return SNMP_ERR_BADVALUE;
        }

      vlan_list = vlan_list->next;
    }
  
   switch (intval)
    {
      case ROW_STATUS_CREATEANDGO:
       {
         if (br_inst && (vlan_list == NULL))
           {
             ret = bitmap_reserve_index (br_inst->vlan_range_index_bmp, 
                                         vlan_range_index);
              if (ret != BITMAP_SUCCESS)
                {
                  pal_mem_set (&tmp_rlist_info, 0, 
                               sizeof (struct tmp_rlist_data));
                  return SNMP_ERR_GENERR;
                }
           }  
      
         for (loop_vlan = tmp_rlist_info.lo; loop_vlan <= tmp_rlist_info.hi;
              loop_vlan++)
            {
               ret = mstp_api_add_instance (br->name, instance_index, 
                                            loop_vlan, vlan_range_index);
               if (ret < 0)
                 {
                   pal_mem_set (&tmp_rlist_info, 0,
                                sizeof (struct tmp_rlist_data));

                   break;

                 } /* if (ret < 0) */
            }

         pal_mem_set (&tmp_rlist_info, 0, sizeof (struct tmp_rlist_data));
            
         break;       
       }
      case ROW_STATUS_DESTROY:
      {
        if (vlan_list == NULL)
          return SNMP_ERR_GENERR;
          
        for (loop_vlan = vlan_list->lo; loop_vlan <= vlan_list->hi;
               loop_vlan++)
          {
            mstp_delete_instance_vlan (br, instance_index, loop_vlan);
          }
      
        break;
      }
      
     default:
       return SNMP_ERR_GENERR;
   }
  return SNMP_ERR_NOERROR;
}      


int
write_dot1sStpVlanTable(int action, u_int8_t * var_val,
                        u_int8_t var_val_type, size_t var_val_len,
                        u_int8_t * statP, oid * name,
                        size_t name_len, struct variable *vp,
                        u_int32_t vr_id)
{

  int ret = 0;
  int instance_index;
  int vlan_range_index;
  struct mstp_bridge *br = NULL;
  struct mstp_bridge_instance *br_inst = NULL;
  struct rlist_info *vlan_list = NULL;
  s_int32_t index_val;
  bool_t entry_found = PAL_FALSE;
  u_int32_t loop_vlan = 0;
  u_int32_t hi = 0;
  u_int32_t lo = 0;
  u_int32_t temp = 0;

  ret = l2_snmp_integer_index_get (vp, name, &name_len,
      &instance_index ,&vlan_range_index,
      1);
  if (ret < 0)
    return SNMP_ERR_GENERR;

  /* Check for the bridge. */
  br = mstp_get_first_bridge ();
  if (br == NULL)
    return SNMP_ERR_GENERR;

  /* Check for the instance in the bridge. */
  br_inst = br->instance_list[instance_index];

  /* Check for the Vlan Index Range. */
  if (br_inst)
    {
      /* Check for the Vlan Range Index. */ 
      vlan_list = br_inst->vlan_list;

      while (vlan_list)
        {
          if (vlan_list->vlan_range_indx == vlan_range_index)
            { 
              /* If the Instance and range exists it is meant
               * for the set operation.
               */
              entry_found = PAL_TRUE;
              break;
            }  

          vlan_list = vlan_list->next;
        }
    }

  if (vlan_list == NULL)
    { 
      if (PAL_TRUE == tmp_rlist_info.creation)
        {
          if ((tmp_rlist_info.instance_index != instance_index) ||
              (tmp_rlist_info.vlan_range_index != vlan_range_index))
            return SNMP_ERR_GENERR;
        }

      tmp_rlist_info.instance_index = instance_index;
      tmp_rlist_info.vlan_range_index = vlan_range_index;
      tmp_rlist_info.creation = PAL_TRUE;
    }


  pal_mem_cpy (&index_val, var_val, sizeof (s_int32_t));

  switch (vp->magic) {
    case DOT1SSTPVLANMIN:
      if (vlan_list) 
        {
          hi = vlan_list->hi;
          lo = vlan_list->lo;

          if ((lo < index_val) && (hi > index_val))
            {
              /* Existing lo vid is being modified */
              for (loop_vlan = lo; loop_vlan<index_val; loop_vlan++)
                {
                  /* Deleting these vlan instances */
                  mstp_delete_instance_vlan (br, instance_index, loop_vlan);
                }
            }/* if (vlan_list->lo < index_val) */
          else if (index_val > hi)
            {
               ret = mstp_api_add_instance (br->name, instance_index,
                  index_val, vlan_range_index);

               if (ret < 0)
                 return SNMP_ERR_GENERR;

              /* Delete all vlans in this list */
              for (loop_vlan = lo; loop_vlan <= hi; loop_vlan++)
                {
                  mstp_delete_instance_vlan (br, instance_index, loop_vlan);
                }
              
              ret = bitmap_reserve_index (br_inst->vlan_range_index_bmp,
                                          vlan_range_index);

            }/* else if (index_val > vlan_list->hi) */
          else if (index_val < lo)
            {
              for (loop_vlan = (lo-1); loop_vlan >= index_val; 
                  loop_vlan--)
                {
                  /* Adding the additional vlans */
                 ret = mstp_api_add_instance (br->name, instance_index,
                       loop_vlan, vlan_range_index);

                 if (ret < 0)
                   {
                     for (temp = loop_vlan; temp < (lo-1); temp++)
                       {
                         mstp_delete_instance_vlan (br, instance_index, temp);
                       }

                     return SNMP_ERR_BADVALUE;
                       
                   }
                }
            }/* else if (index_val < vlan_list->lo) */
        }/* if (vlan_list) */
      else  
        tmp_rlist_info.lo = index_val;
      break;
    case DOT1SSTPVLANMAX:
      if (vlan_list)
        {
          hi = vlan_list->hi;
          lo = vlan_list->lo;

          if ((hi > index_val) && (lo < index_val))
            {
              /* Existing hi vid is being modified */
              for (loop_vlan = hi; loop_vlan > index_val; 
                   loop_vlan--)
                {
                  /* Deleting these vlan instances */
                  mstp_delete_instance_vlan (br, instance_index, loop_vlan);
                }
            }/* if (vlan_list->hi > index_val) */
          else if (index_val > hi)
            {
              for (loop_vlan = (hi+1); loop_vlan <= index_val; 
                   loop_vlan++)
                {
                  ret = mstp_api_add_instance (br->name, instance_index,
                                               loop_vlan, vlan_range_index);
 
                  if (ret < 0)
                   {
                     for (temp = loop_vlan; temp > index_val; temp--)
                       mstp_delete_instance_vlan (br, instance_index, temp);

                     return SNMP_ERR_BADVALUE;
                       
                   }
                }
            }/* else if (index_val > vlan_list->hi) */
          else if (index_val < lo)
            {
              ret = mstp_api_add_instance (br->name, instance_index,
                                           index_val, vlan_range_index);
              if (ret < 0)
                return SNMP_ERR_GENERR;

              for (loop_vlan = hi; loop_vlan > index_val; 
                  loop_vlan--)
                {
                  mstp_delete_instance_vlan (br, instance_index, loop_vlan);
                }

              bitmap_reserve_index (br_inst->vlan_range_index_bmp, 
                                    vlan_range_index);

            }/* else if (index_val < vlan_list->lo) */
        }/* if (vlan_list) */
      else       
        tmp_rlist_info.hi = index_val;
      break;
    default:
      return SNMP_ERR_GENERR;
  }
  return SNMP_ERR_NOERROR;
}


/*
 * var_dot1sStpVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1sStp above.
 */
unsigned char  *
var_dot1sStpVlanTable(struct variable *vp, oid * name,
                      size_t *length, int exact,
                      size_t *var_len, WriteMethod ** write_method,
                      u_int32_t vr_id)
{
  int ret = 0;
  u_int32_t instance_index;
  u_int32_t vlan_range_index;
  struct mstp_bridge *br = NULL;
  struct rlist_info *vlan_list = NULL;
  u_int32_t br_instance_val = -1;
  
 switch (vp->magic) {
  case DOT1SSTPVLANMSTINDEX:
      break;
  case DOT1SSTPVLANRANGEINDEX:
      break;
  case DOT1SSTPVLANMIN:
      *write_method = write_dot1sStpVlanTable;
      break;
  case DOT1SSTPVLANMAX:
      *write_method = write_dot1sStpVlanTable;
      break;
  case DOT1SSTPVLANROWSTATUS:
      *write_method = write_dot1sStpVlanTableRowStatus;
      break;
  default:
      return NULL;
  }

  ret = l2_snmp_integer_index_get (vp, name,length,
                                   &instance_index ,&vlan_range_index,
                                   exact);
  if (ret < 0)
    return NULL;

  /* Check for the bridge. */
  br = mstp_get_first_bridge ();
  if (br == NULL)
    return NULL;

  /* Instance is in the sorted order,  but the vlan_range_index
   * might not be soreted. 
   */
  vlan_list = mstp_instance_entry_get_by_index (br, &br_instance_val, 
                                                instance_index, 
                                                vlan_range_index, exact);

  if (vlan_list == NULL) 
    {
      return NULL; 
    }

  if (br_instance_val == -1)
    return NULL; 

  if (!exact)
     {
       l2_snmp_integer_index_set (vp, name, length,
                                  br_instance_val, vlan_list->vlan_range_indx);
     }

   switch (vp->magic) {
  case DOT1SSTPVLANMSTINDEX:
      MSTP_SNMP_RETURN_INTEGER(br_instance_val);
      break;
  case DOT1SSTPVLANRANGEINDEX:
      MSTP_SNMP_RETURN_INTEGER(vlan_list->vlan_range_indx);
      break;
  case DOT1SSTPVLANMIN:
      MSTP_SNMP_RETURN_INTEGER(vlan_list->lo);
      break;
  case DOT1SSTPVLANMAX:
      MSTP_SNMP_RETURN_INTEGER(vlan_list->hi);
      break;
  case DOT1SSTPVLANROWSTATUS:
      *write_method = write_dot1sStpVlanTableRowStatus;
      MSTP_SNMP_RETURN_INTEGER(ROW_STATUS_ACTIVE);
      break;
    default:
      pal_assert (0);
      return NULL;
    }
      
  return NULL;
}

int
write_dot1sStp_scalars(int action, u_int8_t * var_val,
                       u_int8_t var_val_type, size_t var_val_len,
                       u_int8_t * statP, oid * name,
                       size_t name_len, struct variable *vp,
                       u_int32_t vr_id)
{
  long intval;
  s_int32_t ret;
  s_int8_t cfg_name[MSTP_CONFIG_NAME_LEN + 1]; /* SNMP admin string */
  struct mstp_bridge *br = mstp_get_first_bridge();

  if (br == NULL) 
    return SNMP_ERR_GENERR;

  if (!var_val)
    return SNMP_ERR_GENERR;

  pal_mem_cpy(&intval,var_val,4);

  switch (vp->magic) {
  case DOT1SSTPNAME:
      {
        if (var_val_type != ASN_OCTET_STR)
          return SNMP_ERR_WRONGTYPE;
        
        if (!*var_val)  
          return SNMP_ERR_GENERR;

        if (pal_strlen(var_val) > var_val_len-1) 
          return SNMP_ERR_WRONGLENGTH;

        pal_mem_cpy(cfg_name, var_val, var_val_len);

        ret = mstp_api_region_name (br->name, cfg_name);

        if (ret < 0)
            return SNMP_ERR_GENERR;
      }
      break;

  case DOT1SSTPREVISION:
        {
          ret = mstp_api_revision_number (br->name, intval);

          if (ret < 0)
            return SNMP_ERR_GENERR;
        }
      break;
  case DOT1SSTPENABLE:
        {
          /* Write operation for this is presently not supported */
          /* as disable would lead to deletion of the instance
           * as per implementation and then from CLI we'll have to go 
           * and create instance again. */
#if 0
          if (intval == DOT1SSTPENABLE_TRUE)
            {
              /* Enabling MSTP globally on all the bridging ports */
              ret = mstp_enable_bridge (br);

              if (ret < 0)
                return SNMP_ERR_GENERR;
            }
          else if (intval == DOT1SSTPENABLE_FALSE)
            {
              /* Disabling MSTP globally on all the bridging ports */
              ret = mstp_disable_bridge (br, PAL_TRUE);

              if (ret < 0)
                return SNMP_ERR_GENERR;
            }
          else 
#endif /* 0 */
            return SNMP_ERR_GENERR;
        }
      break;

  case DOT1SSTPBRIDGEMAXAGE:
        {
          if ((intval % 100) || intval < 600 || intval > 4000)
            return SNMP_ERR_BADVALUE;
          if (mstp_api_set_max_age (br->name, intval / 100) != RESULT_OK)
            return SNMP_ERR_BADVALUE;
        }
      break;

  case DOT1SSTPBRIDGEHELLOTIME:
        {
          if ((intval % 100) || intval < 100 || intval > 1000)
            return SNMP_ERR_BADVALUE;
          if (mstp_api_set_hello_time (br->name, intval / 100) !=
              RESULT_OK)
            return SNMP_ERR_BADVALUE;
        }
      break;

  case DOT1SSTPBRIDGEFORWARDDELAY:
        {
          if ((intval % 100) || intval < 400 || intval > 3000)
            return SNMP_ERR_BADVALUE;
          if (mstp_api_set_forward_delay (br->name, intval / 100) !=
              RESULT_OK)
            return SNMP_ERR_BADVALUE;
        }
      break;

  default:
      return SNMP_ERR_GENERR;
  }
  return SNMP_ERR_NOERROR;
}

int
write_dot1sStpInstTable(int action, u_int8_t * var_val,
                        u_int8_t var_val_type, size_t var_val_len,
                        u_int8_t * statP, oid * name,
                        size_t name_len, struct variable *vp,
                        u_int32_t vr_id)
{
  int ret;
  u_int32_t instance_id = 0;
  s_int32_t index_val;
  struct mstp_bridge *br = NULL;
  struct mstp_bridge_instance *br_inst = NULL;

  /* get the port number */
  if ( l2_snmp_index_get (vp, name, &name_len, &instance_id, 1) < 0 )
    return SNMP_ERR_GENERR;

  br = mstp_get_first_bridge ();

  if (br == NULL)
    return SNMP_ERR_GENERR;

  br_inst = br->instance_list[instance_id]; 

  if (br_inst == NULL)
    return SNMP_ERR_GENERR;

  pal_mem_cpy(&index_val, var_val, sizeof (s_int32_t));

  switch (vp->magic) {
  case DOT1SSTPPRIORITY:
      {
        ret = mstp_api_set_msti_bridge_priority (br->name, 
                                                 br_inst->instance_id, 
                                                 index_val);

        if (ret < 0)
          return SNMP_ERR_BADVALUE; 
      }
      break;
  case DOT1SSTPINSTADMINENABLE:
        {
#if defined (HAVE_PROVIDER_BRIDGE) || defined (HAVE_B_BEB)
          if (index_val == PAL_TRUE)
            mstp_enable_bridge_instance (br_inst);
          else
            mstp_disable_bridge_instance (br_inst);
#else
          /* This is not supported on a per-instance basis */
          return SNMP_ERR_GENERR;
#endif /*(HAVE_PROVIDER_BRIDGE) ||(HAVE_B_BEB)*/
        }
      break;
  default:
      return SNMP_ERR_GENERR;
  }
  return SNMP_ERR_NOERROR;
}

int
write_dot1sStpPortTable(int action, u_int8_t * var_val,
                        u_int8_t var_val_type, size_t var_val_len,
                        u_int8_t * statP, oid * name,
                        size_t name_len, struct variable *vp,
                        u_int32_t vr_id)
{
  struct mstp_bridge *br = NULL;
  struct mstp_port *br_port = NULL;
  u_int32_t port;
  long intval;

  if (var_val_type != ASN_INTEGER)
    return SNMP_ERR_WRONGTYPE;

  if (var_val_len != sizeof (long))
    return SNMP_ERR_WRONGLENGTH;

  /* get the port number */
  if ( l2_snmp_index_get (vp, name, &name_len, &port, 1) < 0 )
    return SNMP_ERR_GENERR;

  pal_mem_cpy(&intval,var_val,4);

  br = mstp_get_first_bridge ();
  if (br == NULL)
    return SNMP_ERR_GENERR;

  br_port = mstp_find_cist_port (br, port);
  if (br_port == NULL)
    return SNMP_ERR_GENERR;

  switch (vp->magic) {
  case DOT1SSTPPORTADMINEDGEPORT:
      switch (intval)
        {
        case DOT1SSTPPORTADMINEDGEPORT_TRUE:
          mstp_api_set_port_edge (br->name, br_port->name, PAL_TRUE,
                                  MSTP_CONFIG_PORTFAST);
          break;
        case DOT1SSTPPORTOPEREDGEPORT_FALSE:
          mstp_api_set_port_edge (br->name, br_port->name, PAL_FALSE,
                                  MSTP_CONFIG_PORTFAST);
          break; 
        default:
          return SNMP_ERR_BADVALUE;
        }

      break;
  case DOT1SSTPPORTADMINPOINTTOPOINT:
      switch (intval)
        {
        case DOT1SSTPPORTADMINPOINT2POINT_TRUE:
          mstp_api_set_port_p2p (br->name, br_port->name, PAL_TRUE);
          break;
        case DOT1SSTPPORTADMINPOINT2POINT_FALSE:
          mstp_api_set_port_p2p (br->name, br_port->name, PAL_FALSE);
          break; 
        case DOT1SSTPPORTADMINPOINT2POINT_AUTO:
        default:
          return SNMP_ERR_BADVALUE;
        }
      break;

  default:
      return SNMP_ERR_GENERR;
  }
  return SNMP_ERR_NOERROR;
}

int
write_dot1sStpInstPortTable(int action, u_int8_t * var_val,
                            u_int8_t var_val_type, size_t var_val_len,
                            u_int8_t * statP, oid * name,
                            size_t name_len, struct variable *vp,
                            u_int32_t vr_id)
{
  struct mstp_bridge *br = NULL;
  struct mstp_bridge_instance *br_inst = NULL;
  struct mstp_instance_port *inst_port = NULL;
  struct interface *ifp = NULL;
  struct apn_vr *vr = apn_vr_get_privileged (mstpm);

  s_int32_t ret;
  u_int32_t instIndx;
  u_int32_t portIndx;
  s_int32_t index_val;

  /* get the port number */
  if ( l2_snmp_integer_index_get (vp, name, &name_len, &instIndx, &portIndx, 1) < 0 )
    return SNMP_ERR_GENERR;

  br = mstp_get_first_bridge ();

  if (br == NULL)
    return SNMP_ERR_GENERR;

  br_inst = br->instance_list[instIndx];

  if (br_inst == NULL)
    return SNMP_ERR_GENERR;
    
  inst_port = mstp_find_msti_port (br_inst, portIndx);

  if (inst_port == NULL)
    return SNMP_ERR_GENERR;

  ifp = if_lookup_by_index (&vr->ifm, inst_port->ifindex);
        
  if (ifp == NULL)
    return SNMP_ERR_BADVALUE;

  pal_mem_cpy(&index_val, var_val, sizeof (s_int32_t));

  switch (vp->magic) {
  case DOT1SSTPINSTPORTPRIORITY:
      {
        ret = mstp_api_set_msti_port_priority (br->name, ifp->name, 
                                               inst_port->br->instance_id, 
                                               index_val);

        if (ret < 0)
          return SNMP_ERR_GENERR;
      }
      break;
  case DOT1SSTPINSTPORTPATHCOST:
      {
        ret = mstp_api_set_msti_port_path_cost (br->name, ifp->name,
                                                inst_port->br->instance_id,
                                                index_val);

        if (ret < 0)
          return SNMP_ERR_GENERR;
      }
      break;
  default:
      return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}

#endif /* HAVE_SNMP */
